# Variáveis e tipos de dados
As variáveis e tipos de dados também seguem a mesma lógica de C 

```cpp
int idade = 21;
double altura = 1.75;
char letra = 'A';
```
# Tipos primitivos

| Tipo     | Tamanho | Descrição                         |
| -------- | ------- | --------------------------------- |
| `int`    | 4 bytes | Inteiros                          |
| `float`  | 4 bytes | Ponto flutuante                   |
| `double` | 8 bytes | Ponto flutuante de maior precisão |
| `char`   | 1 byte  | Caractere                         |
| `bool`   | 1 byte  | `true` ou `false`                 |
| `void`   | -       | Sem tipo (funções sem retorno)    |
- Modificadores: short, long, signed, unsigned

## Tipo String 
Para definir uma string segue a mesma lógica que em C, porém, c++ apresenta uma biblioteca que torna essa atividade mais seugra 

```cpp
#include <string>
std::string nome = "João";
```
- Mais segura que char nome[]
- Pertence à STL (std::string)

A biblioteca string permite definir strings, as quais tem seus espaços gerenciados automaticamente, tornadno mais prático e seguro

## Constantes 
A linguagem também apresenta Constantes
```cpp
const double PI = 3.14;
constexpr int TAM = 100; // C++11+
```
- `const`: tipo básico de constante 
- `constexpr`: expressão constante em tempo de compilação. Permitir que variáveis, funções e objetos sejam avaliados em tempo de compilação, otimizando o desempenho. Principalmente usado em casos que indique tamanhos de arrays fixas

### auto 
Basicamente deixa o compilador deduzir o tipo da variável. Eu particulamente não curto muito
```cpp
auto idade = 25;          // int
auto nome = "João";       // const char*
auto nota = 9.75;         // double
auto vetor = std::vector<int>{1, 2, 3};  // std::vector<int>
```
## Inicialização uniforme
Evitar erros de conversão implícita e unificar as formas de inicializar.

```cpp
int x{10};       // inicialização uniforme
double pi{3.14};
std::string nome{"João"};
```

### evita narrowing conversion
É quando você converte um valor de um tipo mais amplo para um tipo mais restrito, perdendo informação no processo.

```cpp 
int x{3.14};  // erro! perde precisão (narrowing)
int y = 3.14; // compila, mas perde o .14 silenciosamente
```


